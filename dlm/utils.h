#pragma once

#include <string>
#include <iostream>
#include <vector>
#include <queue>

// llama.cpp
#include <llama.h>
#include <common.h>

// json
#include <nlohmann/json.hpp>

// debug visualization utils for tokens which were:
//  - matched - generated by both models
//  - rejected - produced by speculation model and did not match
//  - no_matched - produced by main model (and accepted) but not matched with speculation model.
// after each print we swap the bold marker
// to get visual boundaries of token sequences 
// processed in one iteration


void dbg_color(const std::string & s, const std::string & fg)
{
    static const std::string kReset = "\033[0m";
    static const std::string bold[] = { "", "\033[1m" };
    static size_t index = 0;
    std::cout << bold[index] << fg << s << kReset << std::flush;
    index = 1 - index;
}

static void dbg_accepted(const std::string & accepted)
{
    static const std::string kGreen = "\033[32m";
    dbg_color(accepted, kGreen);
}

static void dbg_not_matched(const std::string & accepted)
{
    dbg_color(accepted, "");
}

static void dbg_rejected(const std::string & rejected)
{
    static const std::string kRed = "\033[31m";
    dbg_color(rejected, kRed);
}

static std::vector<llama_token> greedy_tokens(
        llama_model * model,
        llama_context * ctx,
        int from_idx,
        int to_idx)
{
    auto n_vocab = llama_n_vocab(model);
    std::vector<llama_token_data> candidates;
    candidates.resize(n_vocab);
    std::vector<llama_token> res;

    for (int idx = from_idx; idx < to_idx; idx++) {
        auto * logits  = llama_get_logits_ith(ctx, idx);
        for (llama_token token_id = 0; token_id < n_vocab; token_id++) {
            candidates[token_id] = llama_token_data{ token_id, logits[token_id], 0.0f };
        }

        llama_token_data_array candidates_p = { candidates.data(), candidates.size(), false };

        // sample the most likely token
        const llama_token new_token_id = llama_sample_token_greedy(ctx, &candidates_p);
        res.push_back(new_token_id);
    }
    return res;
} 

// simple and not too performant thread-safe queue
template<typename T>
class mt_queue {
    public:
        mt_queue() = default;
        mt_queue(const mt_queue<T>&) = delete;
        mt_queue& operator=(const mt_queue<T>&) = delete;

        void push(T value) {
            std::lock_guard<std::mutex> lock(mutex);
            queue.push(std::move(value));
            cond_var.notify_one();
        }

        T pop() {
            std::unique_lock<std::mutex> lock(mutex);
            cond_var.wait(lock, [this]{ return !queue.empty(); });
            T value = std::move(queue.front());
            queue.pop();
            return value;
        }

        bool empty() const {
            std::lock_guard<std::mutex> lock(mutex);
            return queue.empty();
        }

        size_t size() const {
            std::lock_guard<std::mutex> lock(mutex);
            return queue.size();
        }

    private:
        std::queue<T> queue;
        mutable std::mutex mutex;
        std::condition_variable cond_var;
};
