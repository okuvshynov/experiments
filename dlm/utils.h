#pragma once

#include <string>
#include <iostream>
#include <vector>
#include <queue>

// llama.cpp
#include <llama.h>
#include <common.h>

// json
#include <nlohmann/json.hpp>

// debug visualization utils for tokens which were:
//  - matched - generated by both models
//  - rejected - produced by speculation model and did not match
//  - no_matched - produced by main model (and accepted) but not matched with speculation model.
// after each print we swap the bold marker
// to get visual boundaries of token sequences 
// processed in one iteration


void dbg_color(const std::string & s, const std::string & fg)
{
    static const std::string kReset = "\033[0m";
    static const std::string bold[] = { "", "\033[1m" };
    static size_t index = 0;
    std::cout << bold[index] << fg << s << kReset << std::flush;
    index = 1 - index;
}

static void dbg_accepted(const std::string & accepted)
{
    static const std::string kGreen = "\033[32m";
    dbg_color(accepted, kGreen);
}

static void dbg_not_matched(const std::string & accepted)
{
    dbg_color(accepted, "");
}

static void dbg_rejected(const std::string & rejected)
{
    static const std::string kRed = "\033[31m";
    dbg_color(rejected, kRed);
}

static std::vector<llama_token> greedy_tokens(
        llama_model * model,
        llama_context * ctx,
        int32_t from_idx,
        int32_t to_idx)
{
    auto n_vocab = llama_n_vocab(model);
    std::vector<llama_token> res;
    if (n_vocab <= 0)
    {
        return res;
    }

    for (int idx = from_idx; idx < to_idx; idx++)
    {
        auto * logits  = llama_get_logits_ith(ctx, idx);
        llama_token new_token_id = 0;
        for (llama_token token_id = 1; token_id < n_vocab; token_id++)
        {
            if (logits[token_id] > logits[new_token_id])
            {
                new_token_id = token_id;
            }
        }

        res.push_back(new_token_id);
    }
    return res;
} 

// simple and not too performant thread-safe queue
template<typename T>
class mt_queue {
    public:
        mt_queue() = default;
        mt_queue(const mt_queue<T>&) = delete;
        mt_queue& operator=(const mt_queue<T>&) = delete;

        void push(T value) {
            std::lock_guard<std::mutex> lock(mutex);
            queue.push(std::move(value));
            cond_var.notify_one();
        }

        T pop() {
            std::unique_lock<std::mutex> lock(mutex);
            cond_var.wait(lock, [this]{ return !queue.empty(); });
            T value = std::move(queue.front());
            queue.pop();
            return value;
        }

        bool empty() const {
            std::lock_guard<std::mutex> lock(mutex);
            return queue.empty();
        }

        size_t size() const {
            std::lock_guard<std::mutex> lock(mutex);
            return queue.size();
        }

    private:
        std::queue<T> queue;
        mutable std::mutex mutex;
        std::condition_variable cond_var;
};
