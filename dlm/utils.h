#pragma once

#include <string>
#include <iostream>
#include <vector>
#include <queue>

// llama.cpp
#include <llama.h>
#include <common.h>

namespace llama_peer
{

// debug visualization utils for tokens which were:
//  - matched - generated by both models
//  - rejected - produced by speculation model and did not match
//  - no_matched - produced by main model (and accepted) but not matched with speculation model.
// after each print we swap the bold marker
// to get visual boundaries of token sequences 
// processed in one iteration

void dbg_color(const std::string & s, const std::string & fg)
{
    static const std::string kReset = "\033[0m";
    static const std::string bold[] = { "", "\033[1m" };
    static size_t index = 0;
    std::cout << bold[index] << fg << s << kReset << std::flush;
    index = 1 - index;
}

void dbg_accepted(const std::string & accepted)
{
    static const std::string kGreen = "\033[32m";
    dbg_color(accepted, kGreen);
}

void dbg_not_matched(const std::string & accepted)
{
    dbg_color(accepted, "");
}

void dbg_rejected(const std::string & rejected)
{
    static const std::string kRed = "\033[31m";
    dbg_color(rejected, kRed);
}

std::vector<llama_token> greedy_tokens(
        llama_model * model,
        llama_context * ctx,
        int32_t from_idx,
        int32_t to_idx)
{
    auto n_vocab = llama_n_vocab(model);
    std::vector<llama_token> res;
    if (n_vocab <= 0)
    {
        return res;
    }

    for (int idx = from_idx; idx < to_idx; idx++)
    {
        auto * logits  = llama_get_logits_ith(ctx, idx);
        llama_token new_token_id = 0;
        for (llama_token token_id = 1; token_id < n_vocab; token_id++)
        {
            if (logits[token_id] > logits[new_token_id])
            {
                new_token_id = token_id;
            }
        }

        res.push_back(new_token_id);
    }
    return res;
}

// not very efficient implementation
template<typename iter_t>
uint32_t crc32(iter_t begin, iter_t end)
{
    uint32_t crc = 0xFFFFFFFF;
    for (auto it = begin; it != end; ++it)
    {
        const auto val = *it; 
        const uint8_t * bytes = reinterpret_cast<const uint8_t*>(&val);
        for (uint32_t i = 0; i < sizeof(val); ++i)
        {
            crc = crc ^ bytes[i];
            for (uint32_t j = 0; j < 8; j++)
            {
                if (crc & 1)
                    crc = (crc >> 1) ^ 0xEDB88320;
                else
                    crc = crc >> 1;
            }
        }
    }
    return ~crc;
}

}
